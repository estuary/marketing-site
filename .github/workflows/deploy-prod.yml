name: Deploy to Firebase Hosting

on:
    # TODO scheduled builds
    # schedule:
    #     - cron: '0 5 * * *' # ~ midnight eastern
    #     - cron: '0 13 * * *' # ~ 8 am eastern
    #     - cron: '0 17 * * *' # ~ noon eastern
    #     - cron: '0 23 * * *' # ~ 6 pm eastern
    workflow_dispatch:
    repository_dispatch:
        types: [strapi_updated, postgres_connector_updated]
    push:
        branches:
            - master

concurrency:
    group: prod

jobs:
    # TODO scheduled builds
    # check-recent-build:
    #     runs-on: ubuntu-latest

    #     steps:
    #         - name: Check if triggered by cron
    #           id: check_trigger
    #           run: |
    #               if [ "${{ github.event_name }}" != "schedule" ]; then
    #                 echo "This build was not triggered by a cron job. Skipping previous build checking."
    #                 echo "::set-output name=should_check_build::false"
    #                 echo "::set-output name=should_run::true"
    #               else
    #                 echo "::set-output name=should_check_build::true"
    #               fi

    #         - name: Get previous workflow status
    #           id: get_last_status
    #           uses: adel-s/get-last-workflow-run-info@v1
    #           if: ${{ steps.check_trigger.outputs.should_check_build == 'true' }}
    #           with:
    #               GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    #         - name: Get previous successful workflow run
    #           id: previous_successful_run
    #           if: ${{ steps.check_trigger.outputs.should_check_build == 'true' }}
    #           run: |
    #               # Get the current time and calculate the timestamp for 1 hour ago
    #               current_time=$(date +%s)
    #               one_hour_ago=$((current_time - 3600))

    #               # Get the latest successful run of the 'build_and_preview' job
    #               previous_run=$(gh api repos/${{ github.repository }}/actions/runs \
    #                   --jq ".workflow_runs | map(select(.status == 'success' and .created_at | fromdateiso8601 > $one_hour_ago)) | .[0]")

    #               if [ -z "$previous_run" ]; then
    #                   echo "No successful build in the past hour. Proceeding with the job."
    #                   echo "::set-output name=should_run::true"
    #               else
    #                   echo "A successful build was found in the past hour. Skipping the build."
    #                   echo "::set-output name=should_run::false"
    #               fi

    build_and_preview:
        runs-on: ubuntu-2404-large
        # TODO scheduled builds
        # needs: check-recent-build
        # if: ${{ needs.check-recent-build.outputs.should_run == 'true' }}
        steps:
            - name: Parse Strapi Webhook Payload
              id: parse_webhook
              env:
                  MESSAGE: ${{ toJson(github.event.client_payload) }}
              run: |
                  echo "PAYLOAD: $MESSAGE"
                  
                  # Parse webhook payload to determine what content changed
                  if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
                      DISPATCH_TYPE="${{ github.event.action }}"
                      echo "Dispatch type: $DISPATCH_TYPE"
                      
                      if [ "$DISPATCH_TYPE" = "strapi_updated" ]; then
                          # Extract model and entry information from Strapi webhook
                          MODEL=$(echo "$MESSAGE" | jq -r '.model // "unknown"')
                          ENTRY_ID=$(echo "$MESSAGE" | jq -r '.entry.id // "unknown"')
                          ENTRY_SLUG=$(echo "$MESSAGE" | jq -r '.entry.slug // "unknown"')
                          
                          echo "Strapi - Changed model: $MODEL"
                          echo "Strapi - Entry ID: $ENTRY_ID"
                          echo "Strapi - Entry slug: $ENTRY_SLUG"
                          
                          # Set outputs for later steps
                          echo "changed_model=$MODEL" >> $GITHUB_OUTPUT
                          echo "entry_id=$ENTRY_ID" >> $GITHUB_OUTPUT
                          echo "entry_slug=$ENTRY_SLUG" >> $GITHUB_OUTPUT
                          echo "change_source=strapi" >> $GITHUB_OUTPUT
                          
                          # Determine if this affects connector content
                          if [ "$MODEL" = "connector" ]; then
                              echo "Strapi connector content changed: $ENTRY_SLUG"
                              echo "connector_changed=true" >> $GITHUB_OUTPUT
                              echo "changed_connector_slug=$ENTRY_SLUG" >> $GITHUB_OUTPUT
                          else
                              echo "Other Strapi content changed: $MODEL"
                              echo "connector_changed=false" >> $GITHUB_OUTPUT
                          fi
                          
                      elif [ "$DISPATCH_TYPE" = "postgres_connector_updated" ]; then
                          # Extract connector information from Postgres webhook
                          CONNECTOR_SLUG=$(echo "$MESSAGE" | jq -r '.connector_slug // "unknown"')
                          CONNECTOR_ID=$(echo "$MESSAGE" | jq -r '.connector_id // "unknown"')
                          CHANGE_TYPE=$(echo "$MESSAGE" | jq -r '.change_type // "unknown"')
                          
                          echo "Postgres - Connector slug: $CONNECTOR_SLUG"
                          echo "Postgres - Connector ID: $CONNECTOR_ID"
                          echo "Postgres - Change type: $CHANGE_TYPE"
                          
                          # Set outputs for later steps
                          echo "changed_model=connector" >> $GITHUB_OUTPUT
                          echo "entry_id=$CONNECTOR_ID" >> $GITHUB_OUTPUT
                          echo "entry_slug=$CONNECTOR_SLUG" >> $GITHUB_OUTPUT
                          echo "change_source=postgres" >> $GITHUB_OUTPUT
                          echo "change_type=$CHANGE_TYPE" >> $GITHUB_OUTPUT
                          
                          echo "ðŸŽ¯ Postgres connector metadata changed: $CONNECTOR_SLUG"
                          echo "connector_changed=true" >> $GITHUB_OUTPUT
                          echo "changed_connector_slug=$CONNECTOR_SLUG" >> $GITHUB_OUTPUT
                      fi
                  else
                      echo "ðŸ”„ Manual or push trigger - full rebuild"
                      echo "connector_changed=false" >> $GITHUB_OUTPUT
                  fi

            - name: Checkout
              uses: actions/checkout@v3
              with:
                  fetch-depth: 20

            - uses: actions/setup-node@v1
              with:
                  node-version: '20.x'

            - name: Caching
              id: gatsby-cache-build
              uses: actions/cache@v4
              with:
                  path: |
                      node_modules
                      .cache
                      public
                  key: ${{ runner.os }}-gatsby-build-prod-${{ hashFiles('**/package-lock.json', '**/yarn.lock', 'gatsby-config.ts', 'gatsby-node.ts') }}
                  restore-keys: |
                      ${{ runner.os }}-gatsby-build-prod-

            - run: yarn install

            - name: Run ESLint
              run: yarn lint
              env:
                  CI: true
            - name: Run Prettier
              run: yarn format
              env:
                  CI: true

            - name: Build Gatsby Site
              run: yarn run build --verbose --log-pages
              env:
                  CI: true
                  GATSBY_EXPERIMENTAL_PAGE_BUILD_ON_DATA_CHANGES: true
                  GATSBY_CPU_COUNT: 4
                  # Webhook information for selective builds
                  WEBHOOK_MODEL: ${{ steps.parse_webhook.outputs.changed_model }}
                  WEBHOOK_ENTRY_SLUG: ${{ steps.parse_webhook.outputs.changed_connector_slug }}
                  WEBHOOK_CHANGE_SOURCE: ${{ steps.parse_webhook.outputs.change_source }}
                  CONNECTOR_CHANGED: ${{ steps.parse_webhook.outputs.connector_changed }}
                  # Legacy support (can be removed later)
                  STRAPI_CONNECTOR_CHANGED: ${{ steps.parse_webhook.outputs.connector_changed }}
                  STRAPI_WEBHOOK_ENTRY_SLUG: ${{ steps.parse_webhook.outputs.changed_connector_slug }}
                  # Connection credentials
                  STRAPI_API_URL: ${{ secrets.STRAPI_API_URL }}
                  STRAPI_TOKEN: ${{ secrets.STRAPI_TOKEN }}
                  GATSBY_DB_USER: ${{ secrets.GATSBY_DB_USER }}
                  GATSBY_DB_PASS: ${{ secrets.GATSBY_DB_PASS }}
                  GATSBY_DB_HOST: ${{ secrets.GATSBY_DB_HOST }}
                  GATSBY_DB_PORT: ${{ secrets.GATSBY_DB_PORT }}
                  GATSBY_DB_NAME: ${{ secrets.GATSBY_DB_NAME }}

            - uses: FirebaseExtended/action-hosting-deploy@v0
              with:
                  repoToken: '${{ secrets.GITHUB_TOKEN }}'
                  firebaseServiceAccount: '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}'
                  expires: 30d
                  projectId: estuary-marketing
                  channelId: live
            - name: Cleanup
              run: |
                  gh extension install actions/gh-actions-cache

                  REPO=${{ github.repository }}
                  BRANCH="master"
                  
                  # Only clean up old caches (keep recent ones for incremental builds)
                  echo "Cleaning up caches older than 7 days..."
                  
                  # Get current cache key pattern
                  CURRENT_CACHE_PREFIX="${{ runner.os }}-gatsby-build-prod-"
                  
                  # List all caches and filter by age (GitHub API doesn't provide creation date directly)
                  # For now, keep the 5 most recent caches and delete older ones
                  cacheKeys=$(gh actions-cache list -R $REPO -B $BRANCH --limit 100 | cut -f 1)
                  
                  # Convert to array and keep only first 5 (most recent)
                  cacheArray=($cacheKeys)
                  if [ ${#cacheArray[@]} -gt 5 ]; then
                      echo "Found ${#cacheArray[@]} caches, keeping 5 most recent"
                      for (( i=5; i<${#cacheArray[@]}; i++ )); do
                          echo "Deleting old cache: ${cacheArray[i]}"
                          gh actions-cache delete "${cacheArray[i]}" -R $REPO --confirm || true
                      done
                  else
                      echo "Found ${#cacheArray[@]} caches, keeping all"
                  fi
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
